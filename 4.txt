def mod_exp(base, exp, mod):
    return pow(base, exp, mod)

def main():
    # Public parameters (example)
    p = 23  # prime
    g = 5   # generator

    # Private keys (Rohan, Raj, Pratham(MITM))
    r = 6   # Rohan's private key
    ra = 15 # Raj's private key
    pr = 7  # Pratham's private key (MITM)

    # Public keys computed from private keys
    R = mod_exp(g, r, p)     # Rohan's public key
    RA = mod_exp(g, ra, p)   # Raj's public key
    PR = mod_exp(g, pr, p)   # Pratham's public key (same value sent to both)

    print("Choose an option:")
    print("1. Exchange Public Keys between Rohan and Raj (normal)")
    print("2. Perform Man-In-The-Middle Attack by Pratham")
    choice = input("Enter 1 or 2: ").strip()

    if choice == "1":
        # Normal exchange
        print("\n--- Normal Diffie-Hellman Exchange ---")
        print(f"Rohan's Public Key: {R}")
        print(f"Raj's Public Key  : {RA}")

        # Each computes shared secret
        S_Rohan = mod_exp(RA, r, p)
        S_Raj = mod_exp(R, ra, p)

        print(f"Rohan computes shared secret: {S_Rohan}")
        print(f"Raj computes shared secret  : {S_Raj}")

        if S_Rohan == S_Raj:
            print("Result: Secure communication established.\n")
        else:
            print("Result: Shared secrets do not match!\n")

    elif choice == "2":
        # MITM attack
        print("\n--- Man-In-The-Middle (MITM) by Pratham ---")
        print(f"Rohan's Public Key: {R}")
        print(f"Raj's Public Key  : {RA}")

        # Pratham intercepts and replaces public keys with his own
        print(f"Pratham intercepts and sends to Rohan: {PR}")
        print(f"Pratham intercepts and sends to Raj  : {PR}")

        # Rohan computes shared secret thinking he's with Raj (but with Pratham's key)
        S_Rohan = mod_exp(PR, r, p)
        print(f"Rohan computes shared secret with (what he thinks is Raj): {S_Rohan}")

        # Raj computes shared secret thinking he's with Rohan (but with Pratham's key)
        S_Raj = mod_exp(PR, ra, p)
        print(f"Raj computes shared secret with (what he thinks is Rohan): {S_Raj}")

        # Pratham actually knows both secrets:
        S_PrathamRohan = mod_exp(R, pr, p)   # using Rohan's public key and Pratham's private
        S_PrathamRaj = mod_exp(RA, pr, p)    # using Raj's public key and Pratham's private
        print(f"Pratham computes shared secret with Rohan: {S_PrathamRohan}")
        print(f"Pratham computes shared secret with Raj  : {S_PrathamRaj}")

        if S_Rohan == S_PrathamRohan and S_Raj == S_PrathamRaj:
            print("\nResult: Man-In-The-Middle attack successful. Pratham can intercept/modify messages.\n")
        else:
            print("\nResult: MITM attack failed!\n")

    else:
        print("\nInvalid option! Please run again and enter 1 or 2.\n")


if __name__ == "__main__":
    main()

//without function
#include <iostream>
using namespace std;

// Fast modular exponentiation: (base^exp) % mod
long long mod_exp(long long base, long long exp, long long mod) {
    long long res = 1;
    base %= mod;
    while (exp > 0) {
        if (exp & 1) res = (res * base) % mod;
        base = (base * base) % mod;
        exp >>= 1;
    }
    return res;
}

// Compute shared secret: otherPublic^private mod p
long long shared_secret(long long otherPub, long long priv, long long p) {
    return mod_exp(otherPub, priv, p);
}

int main() {
    // Prime (p) and generator (g)
    const long long p = 23;
    const long long g = 5;

    // Private keys
    const long long r  = 6;  // Rohan
    const long long ra = 15; // Raj
    const long long pr = 7;  // Pratham (attacker)

    // Public keys: g^private mod p
    const long long R   = mod_exp(g, r, p);  // Rohan's public
    const long long RA  = mod_exp(g, ra, p); // Raj's public
    const long long PR  = mod_exp(g, pr, p); // Pratham's public (used for MITM)

    cout << "Choose an option:\n1. Normal DH exchange\n2. MITM by Pratham\n> ";
    int choice; cin >> choice;

    if (choice == 1) {
        // Normal exchange: Rohan <-> Raj
        cout << "Rohan's Public : " << R  << "\n";
        cout << "Raj's Public   : " << RA << "\n";

        long long S_rohan = shared_secret(RA, r, p);
        long long S_raj   = shared_secret(R,  ra, p);

        cout << "Rohan's secret: " << S_rohan << "\n";
        cout << "Raj's secret  : " << S_raj   << "\n";

        cout << (S_rohan == S_raj ? "Secure communication established.\n"
                                : "Shared secrets do not match!\n");
    }
    else if (choice == 2) {
        // MITM scenario: Pratham intercepts and substitutes public keys
        cout << "Rohan's Public : " << R  << "\n";
        cout << "Raj's Public   : " << RA << "\n";

        // Attacker sends PR to both parties
        cout << "Pratham sends his public key to Rohan: " << PR << "\n";
        cout << "Pratham sends his public key to Raj  : " << PR << "\n";

        // Each party computes a secret (actually with Pratham)
        long long S_rohan = shared_secret(PR, r, p);  // Rohan <> Pratham
        long long S_raj   = shared_secret(PR, ra, p); // Raj   <> Pratham

        // Pratham computes both shared secrets using intercepted publics
        long long S_pr_rohan = shared_secret(R,  pr, p);  // with Rohan
        long long S_pr_raj   = shared_secret(RA, pr, p);  // with Raj

        cout << "Rohan computes secret (with Pratham): " << S_rohan << "\n";
        cout << "Raj   computes secret (with Pratham): " << S_raj   << "\n";
        cout << "Pratham's secret with Rohan         : " << S_pr_rohan << "\n";
        cout << "Pratham's secret with Raj           : " << S_pr_raj   << "\n";

        cout << ((S_rohan == S_pr_rohan && S_raj == S_pr_raj)
                 ? "MITM successful: Pratham can intercept/modify messages.\n"
                 : "MITM failed.\n");
    }
    else {
        cout << "Invalid option.\n";
    }
    return 0;
}
